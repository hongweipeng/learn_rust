use std::ptr::eq;

/**
 * åŸç”Ÿæ•°æ®ç±»å‹
 *
 * æ ‡é‡ç±»å‹ï¼ˆscalar typeï¼‰ï¼š
 *  - æœ‰ç¬¦å·æ•´å‹ï¼ˆsigned integersï¼‰ï¼ši8ã€i16ã€i32ã€i64 å’Œ isizeï¼ˆæŒ‡é’ˆå®½åº¦ï¼‰
 *  - æ— ç¬¦å·æ•´å‹ï¼ˆunsigned integersï¼‰ï¼š u8ã€u16ã€u32ã€u64 å’Œ usizeï¼ˆæŒ‡é’ˆå®½ åº¦ï¼‰
 *  - æµ®ç‚¹ç±»å‹ï¼ˆfloating pointï¼‰ï¼š f32ã€f64
 *  - charï¼ˆå­—ç¬¦ï¼‰ï¼šå•ä¸ª Unicode å­—ç¬¦ï¼Œå¦‚ 'a'ï¼Œ'Î±' å’Œ 'âˆ'ï¼ˆæ¯ä¸ªéƒ½æ˜¯ 4 å­—èŠ‚ï¼‰
 *  - boolï¼ˆå¸ƒå°”å‹ï¼‰ï¼šåªèƒ½æ˜¯ true æˆ– false
 *  - å•å…ƒç±»å‹ï¼ˆunit typeï¼‰ï¼š()ã€‚å…¶å”¯ä¸€å¯èƒ½çš„å€¼å°±æ˜¯ () è¿™ä¸ªç©ºå…ƒç»„ï¼Œå°½ç®¡å•å…ƒç±»å‹çš„å€¼æ˜¯ä¸ªå…ƒç»„ï¼Œå®ƒå´å¹¶ä¸è¢«è®¤ä¸ºæ˜¯å¤åˆç±»å‹ï¼Œå› ä¸ºå¹¶ä¸åŒ…å«å¤šä¸ªå€¼ã€‚
 *
 * å¤åˆç±»å‹ï¼ˆcompound typeï¼‰ï¼š
 *  - æ•°ç»„ï¼ˆarrayï¼‰ï¼šå¦‚ [1, 2, 3]
 *  - å…ƒç»„ï¼ˆtupleï¼‰ï¼šå¦‚ (1, true)
 */

// å­—é¢é‡å’Œè¿ç®—ç¬¦
/*
 æ•´æ•° 1
 æµ®ç‚¹æ•° 1.2
 å­—ç¬¦ 'a'
 å­—ç¬¦ä¸² "abc"
 å¸ƒå°”å€¼ true
 å•å…ƒç±»å‹ ()
 å¯ä»¥ç”¨æ•°å­—ã€æ–‡å­—æˆ–ç¬¦å·ä¹‹ç±»çš„ â€œå­—é¢é‡â€ï¼ˆliteralï¼‰æ¥è¡¨ç¤ºã€‚
 */


// æ•´å‹ç±»å‹
#[test]
fn test_integer_type() {
    /*
    æ— ç¬¦å·æ•´æ•°ç±»å‹ä»¥ u å¼€å¤´
    æœ‰ç¬¦å·æ•´æ•°ç±»å‹ä»¥ i å¼€å¤´

    æ•´æ•°ç±»å‹åˆ—è¡¨å¦‚å›¾
    | Length  | Signed | Unsigned |
    | ------- | ------ | -------- |
    | 8-bit   | i8     | u8       |
    | 16-bit  | i16    | u16      |
    | 32-bit  | i32    | u32      |
    | 64-bit  | i64    | u64      |
    | 128-bit | i128   | u128     |
    | arch    | isize  | usize    |

    isize å’Œ usize çš„ä½æ•°æœ‰è®¡ç®—æœºæ¶æ„å†³å®šï¼Œå¦‚æœæ˜¯ 64 ä½è®¡ç®—æœºï¼Œé‚£å°±æ˜¯ 64 ä½çš„ã€‚
    å¦å¤–ï¼Œé€šè¿‡åŠ å‰ç¼€ 0xã€0oã€0bï¼Œæ•°å­—å¯ä»¥ç”¨åå…­è¿›åˆ¶ã€å…«è¿›åˆ¶æˆ–äºŒè¿›åˆ¶è®°æ³•è¡¨ç¤ºã€‚
     */


    // ä¸ºäº†æ”¹å–„å¯è¯»æ€§ï¼Œå¯ä»¥åœ¨æ•°å€¼å­—é¢é‡ä¸­æ’å…¥ä¸‹åˆ’çº¿
    let large = 1_000;
    let rate = 0.000_001;
    assert_eq!(1000, large);
    assert_eq!(0.000001, rate);

    let num = 18;   // ä¼šé»˜è®¤ä½¿ç”¨ i32 ç±»å‹
    let num : i64 = 18;  // æŒ‡å®šå…·ä½“ç±»å‹
    let num = 18i64;    // é™¤äº† byte ç±»å‹å¤–ï¼Œæ‰€æœ‰å­—é¢å€¼éƒ½å…è®¸ä½¿ç”¨ç±»å‹åç¼€
    let num = 0xff; // 0x å‰ç¼€åå…­è¿›åˆ¶
    let num = 0o77; // 0o å‰ç¼€å…«è¿›åˆ¶
    let num = 0b1111_0000;  // 0b äºŒè¿›åˆ¶
    let byte = b'A'; // å­—èŠ‚ï¼Œåªèƒ½å£°æ˜ä¸º u8 ç±»å‹

}

#[test]
fn test_integer_compute() {
    // æ•´æ•°ç›¸åŠ 
    println!("1 + 2 = {}", 1u32 + 2);

    // æ•´æ•°ç›¸å‡
    println!("1 - 2 = {}", 1i32 - 2);


    // æº¢å‡ºæ£€æŸ¥
    // è°ƒè¯•æ¨¡å¼ä¸‹çš„ç¼–è¯‘é˜¶æ®µä¼šæ£€æŸ¥å‡ºæº¢å‡ºä»ä¸èƒ½é€šè¿‡
    // å‘å¸ƒæ¨¡å¼ä¸‹çš„ç¼–è¯‘åˆ™ä¸ä¼šæ£€æŸ¥æº¢å‡º
    // let num = 1u32 - 2;
    // let num = 4294967296i64 * 4294967296i64 * 4294967296i64;

    // æ•´æ•°ç›¸é™¤, å¾—åˆ°æ˜¯æ•´æ•°å»ä½™æ•°å¤„ç†
    let num = 64 / 5;
    assert_eq!(12, num);

    // é€šè¿‡ç±»å‹è½¬æ¢ä¸ºæµ®ç‚¹ç±»å‹æ‰èƒ½å¾—åˆ°æµ®ç‚¹æ•°(é™¤æ•°ä¸è¢«é™¤æ•°éƒ½è¦æ˜¯æµ®ç‚¹ç±»å‹)
    let num =  (64 as f64) / (5 as f64);
    assert_eq!(12.8, num);

    // é™¤æ³•å–ä½™
    let num = 54 % 5;
    assert_eq!(4, num);

    // ä½è¿ç®—
    println!("0011 AND 0101 is {:04b}", 0b0011u32 & 0b0101);
    println!("0011 OR 0101 is {:04b}", 0b0011u32 | 0b0101);
    println!("0011 XOR 0101 is {:04b}", 0b0011u32 ^ 0b0101);
    println!("1 << 5 is {}", 1u32 << 5);
    println!("0x80 >> 2 is 0x{:x}", 0x80u32 >> 2);

}

#[test]
fn test_float_type(){
    /*
    Rust æœ‰ä¸¤ç§åŸºç¡€çš„æµ®ç‚¹ç±»å‹
    f32, 32ä½, å•ç²¾åº¦
    f64, 64ä½, åŒç²¾åº¦

    f64 æ˜¯é»˜è®¤ç±»å‹,åœ¨ç°ä»£ CPU ä¸­,å•ç²¾åº¦å’ŒåŒç²¾åº¦é€Ÿåº¦å·®ä¸å¤š
     */
    let money = 2.0;    // é»˜è®¤ä½¿ç”¨ f64
    let money : f32 = 2.0;

    assert_eq!(2.0, money);
}

#[test]
fn test_bool_type() {
    /*
    å¸ƒå°”ç±»å‹åªæœ‰ä¸¤ä¸ªå€¼ï¼štrue å’Œ false
    å†…å­˜ä¸­åªå  1 ä¸ªå­—èŠ‚å¤§å°
     */
    let t = true;
    let f : bool = false;

    // å¸ƒå°”é€»è¾‘åˆ¤æ–­ä½¿ç”¨çŸ­è·¯æ±‚å€¼çš„æ–¹å¼
    assert!(t);
    assert!(!f);
    assert!(t && t);
    assert!(f || t);
}

#[test]
fn test_char_type() {
    /*
    char ç±»å‹æ˜¯æè¿°é‡Œæœ€åŸºç¡€çš„å•ä¸ªå­—ç¬¦
    å­—ç¬¦çš„å­—é¢å€¼ä½¿ç”¨å•å¼•å·
    å†…å­˜å ç”¨ 4 å­—èŠ‚ä»£é”€
    æ˜¯ Unicode æ ‡é‡å€¼ï¼Œå¯ä»¥æ˜¯ asciiï¼Œæ‹¼éŸ³ï¼Œè¡¨æƒ…ç­‰
    èŒƒå›´ï¼šU+0000 ~ U+D7FF
         U+E000 ~ U+10FFFF
     */
    let ch = 'z';
    let ch : char = 'ä¸­';
    let ch : char = '\0';
    let ch : char = '\n';
    let ch : char = 'ğŸ˜Š';

}

#[test]
fn test_tuple_type() {
    /*
    tuple å¯ä»¥å°†å¤šä¸ªç±»å‹çš„å¤šä¸ªå€¼æ”¾åœ¨ä¸€ä¸ªç±»å‹é‡Œ
    tuple çš„é•¿åº¦æ˜¯å›ºå®šçš„ï¼Œä¸€æ—¦å£°æ˜å°±æ— æ³•æ”¹å˜
     */
    let empty = (); // ç©ºå…ƒç»„
    let tup = (500, 6.4, true);
    let tup : (i32, f64, bool) = (500, 6.4, true);  // å¯ä»¥æ˜¾ç¤ºå£°æ˜å…ƒç´ ç±»å‹

    // å…ƒç»„é‡Œå–å€¼
    assert_eq!(500, tup.0);
    assert_eq!(6.4, tup.1);
    assert_eq!(true, tup.2);

    // å…ƒç»„æ²¡æœ‰è·å¾—å…¶é•¿åº¦çš„æ–¹æ³•
    //tup.len();

    // å…ƒç»„çš„å…ƒç´ ä¸èƒ½é‡æ–°èµ‹å€¼
    //tup.0 = 1;

    // å…ƒç»„å¯ç”¨äºæ‹†åŒ…
    let (x, y) = (1, 2);
    assert_eq!(1, x);
    assert_eq!(2, y);
    // æ‹†åŒ…å·¦å³æ•°é‡ä¸åŒ¹é…æ—¶ï¼Œç¼–è¯‘æŠ¥é”™
    // let (x, y) = (1, 2, 3, 4, 5);
    // å¯ä»¥ä½¿ç”¨ _ ä½œä¸ºå ä½
    let (x, y, _, _, _) = (1, 2, 3, 4, 5);
    assert_eq!(1, x);
    assert_eq!(2, y);

    // ä½†å¾ˆé•¿çš„å…ƒç»„æ— æ³•æ‰“å°
    let too_long_tuple = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13);
    // println!("too long tuple: {:?}", too_long_tuple);

}

#[test]
fn test_list_type() {
    /*
    æ•°ç»„é‡Œçš„æ¯ä¸ªå…ƒç´ çš„ç±»å‹éƒ½æ˜¯ç›¸åŒçš„
    æ•°ç»„çš„é•¿åº¦æ˜¯å›ºå®šçš„,è‹¥éœ€è¦è¾¹é•¿,æ¨èä½¿ç”¨ Vector
    æ•°ç»„çš„ç´¢å¼•å…ƒç´ å¯ä»¥é‡æ–°èµ‹å€¼
     */

    // æ•°ç»„çš„å£°æ˜ï¼šåœ¨ä¸­æ‹¬å·ä¸­ï¼Œå„å€¼ç”¨é€—å·åˆ†å¼€
    let mut arr = [1, 2, 3, 4, 5];
    // å¦‚æœæ•°ç»„é‡Œæ¯ä¸ªå…ƒç´ éƒ½ç›¸åŒ,å¯ä»¥ç”¨ ; + é•¿åº¦ çš„æ–¹å¼å£°æ˜
    let a = [3; 5]; // ç­‰ä»·äº let a = [3, 3, 3, 3, 3];

    // æ•°ç»„å–å€¼
    assert_eq!(1, arr[0]);
    assert_eq!(2, arr[1]);

    // æ•°ç»„å…ƒç´ é‡æ–°èµ‹å€¼, éœ€è¦å£°æ˜æ•°ç»„æ˜¯ mut çš„
    arr[0] = 100;
    assert_eq!(100, arr[0]);

    // æ•°ç»„çš„é•¿åº¦
    assert_eq!(5, arr.len());

    // è¶Šç•Œçš„ä¸‹æ ‡æ—¶,ç¼–è¯‘ä¼šé€šè¿‡,è¿è¡Œä¼šå¼•å‘è‡´å‘½é”™è¯¯ï¼ˆpanicï¼‰
    // println!("{}", arr[100]);

}

#[test]
fn test_str_change_to_int() {
    // å­—ç¬¦ä¸²è½¬æ•´å‹
    let guess: u32 = "42".parse().expect("Not a number!");
    assert_eq!(42, guess);
}

#[test]
fn test_array_and_slice() {
    // æ•°ç»„ä¸­çš„å…ƒç´ ç±»å‹å¿…é¡»éƒ½æ˜¯ä¸€æ ·çš„
    // æ•°ç»„æ˜¯ç”¨æ¥å£°æ˜å®šé•¿çš„ï¼Œè‹¥éœ€è¦å˜é•¿æ•°ç»„ï¼Œåº”è¯¥ä½¿ç”¨ vector

    // å£°æ˜å›ºå®šå¤§å°çš„æ•°ç»„
    let xs: [i32; 5] = [1, 2, 3, 4, 5];

    // All elements can be initialized to the same value
    let ys: [i32; 500] = [0; 500];
    assert_eq!(0, ys[400]);
    assert_eq!(500, ys.len());

    // slice
    let pick = &xs[1..4]; // ä»ç´¢å¼•1å–åˆ°ç´¢å¼•4ï¼ˆä¸åŒ…å«4ï¼‰ pick = [2, 3, 4];
    assert_eq!(3, pick.len());
    assert_eq!(2, pick[0]);
    assert_eq!(3, pick[1]);
    assert_eq!(4, pick[2]);

}

